<html>
  <body>
    <h1>Resumo honesto de org</h1>
      <h2>p1</h2>
        <p>
          <h3>aula 1 = Visão geral de organização de um computador - INFORMATIVO</h3>
            NÃO INTERESSA
        </p>

        <p>
          <h3>aula 2 = Introdução à programação de sistemas - INFORMATIVO</h3>
            <ul>
              <li>Linguagem de máquina = 0's e 1's</li>
              <li>Linguagem de montagem = simbólica/mnemonicos</li>
              <li>Assembly = legibilidade baixa e produtividade menor</li>
            </ul>
        </p>

        <p>
        <h3>aula 3 = Conjunto de instruções - FORMATIVO</h3>
          <ul>
            <li>32 registradores de uso geral de 32 bits e intruções de 32 bits</li>
            <li>Banco de registradores: $zero, $at, $v0, $v1, $a0...$a3, $t0..$t9, $s0..$s7, $k0, $k1, $gp, $sp, $fp, $ra</li>
            <li>Máquina LOAD-STORE: existem instruções específicas para se acessar a memória e somente estas o acessam(lw, sw)</li>
            <li>Demais instruções acessam operando em REGISTRADORES.</li>
            <li>Ordem dos bits: </li>
              <ul>
                <li>Big Endian: [0,1,2,3] => ordem dos bytes em uma palavra</li>
                  <ul>
                    <li>[0,1,2,3] [4,5,6,7] [8,9,10,11] => várias palavras</li>
                  </ul>
                <li>Little Endian: [3,2,1,0] => ordem dos bytes em uma palavra</li>
                  <ul>
                    <li>[3,2,1,0] [7,6,5,4] [11,10,9,8] => várias palavras</li>
                  </ul>
                  <li>Isto é: [0x12345678] -> big endian será [x078563412] -> little endian (O VALOR NÃO MUDA, MAS SIM O MODO COMO SE LÊ).</li>
              </ul>
            <li>Alinhamento: dado contíguo em memória.</li>
              <ul>
                <li>Alinhado dado 'XXXXXXXX': word 1 - [XX XX XX XX]</li>
                <li>Desalinhado dado 'XXXXXXXX': word 1 - [?? ? XX XX], word 2 - [XX XX ?? ??]</li></li>
                <li>OBS: nºs inteiros(word) multiplicamos por 4, half word por 2, e byte por 1(não precisa).</li>
              </ul>
            <li>Instruções imediatas: constante imbutida na instrução. Ex: addi $s1, $s1, 3($s1 = $s1 + 3)</li>
            <li>Formatos de instrução: (opcode = código de operação, rs e rt = registradores,
                rd = registrador de destino, shamt = shift amount, funct = função).</li>
              <ul>
                <li>R = [6 bits(opcode) | 5 bits(rs) | 5 bits (rt) | 5 bits(rd) | 5 bits(shamt) | 6 bits(funct)]</li>
                <li>I = [6 bits(opcode) | 5 bits(rs) | 5 bits (rt) | 16 bits(constante ou endereço) ]</li>
              </ul>
            <li>Geração de código para 'A[200] = h + A[200];' (Assumindo: $t1 = BASE de A, $s2 = h):</li>
              <ol>
                <li>lw $t0, 800($t1)    #carrega em $t0 = a[200], 800 porque multiplicamos por 4 = 1 word = 32 bits = 1 inteiro</li>
                <li>add $t0, $s2, $t0   #$t0 = $s2 + $t0, ou seja: A[200] = h + A[200]</li>
                <li>sw $t0, 800($t1)    #salva na memória A[200], cuja base do endereço encontra-se em $t1</li>
              </ol>
          </ul>
          
        <p>
         <h3>aula 4 = Conjunto de instruções - FORMATIVO</h3>
           <ul>
            <li>Operações lógicas:</li>
              <ul>
                <li>shift left = << em C = sll em MIPS</li>
                      &nbsp&nbsp&nbsp sll $t2, $s0, 4 #$t2 = $s0 << 4 bits <br>
                      &nbsp&nbsp&nbsp $s0 = 0000 0000 0000 0000 0000 0000 0000 1000 <br>
                      &nbsp&nbsp&nbsp $t2 = 0000 0000 0000 0000 0000 0000 1000 0000
                <li>shift right = >> em C = srl em MIPS</li>
                <li>AND bit-a-bit = & em C = and, andi em MIPS</li>
                      &nbsp&nbsp&nbsp and $t0, $t1, $2, 4 #$t0 = $t1 & $t2 <br>
                      &nbsp&nbsp&nbsp $t2 = 0000 0000 0000 1000 0000 0000 1100 1000 <br>
                      &nbsp&nbsp&nbsp $t1 = 0000 0000 0100 0000 1000 0000 1100 0000 <br>
                      &nbsp&nbsp&nbsp $t0 = 0000 0000 0000 0000 0000 0000 1100 0000
                      </li>
                <li>OR bit-a-bit = | em C = or, ori em MIPS</li>
                      &nbsp&nbsp&nbsp or $t0, $t1, $2, 4 #$t0 = $t1 | $t2 <br>
                      &nbsp&nbsp&nbsp $t2 = 0000 0000 0000 1000 0000 0000 1100 1000 <br>
                      &nbsp&nbsp&nbsp $t1 = 0000 0000 0100 0000 1000 0000 1100 0000 <br>
                      &nbsp&nbsp&nbsp $t0 = 0000 0000 0100 1000 0000 0000 1100 1000
                <li>NOT bit-a-bit = ~ em C = nor em MIPS</li>
              </ul>
            <li>Desvios:</li>
              <ul>
                <li>Condicional:</li>
                &nbsp&nbsp&nbsp beq reg1, reg2, L1 #se reg1 = reg2, vá para o endereço L1 <br>
                &nbsp&nbsp&nbsp bne reg1, reg2, L1 #se reg1 != reg2, vá para o endereço L1
                <li>Incondicional:</li>
                &nbsp&nbsp&nbsp j L1 #vá para o endereço L1
              </ul>
            <li>CONTINUA...</li>
           </ul>
        </p>

        <p>
          <h3>aula 5 = Conjunto de instruções - FORMATIVO</h3>
            <ul>
            </ul>
        </p>

        <p>
          <h3>aula 6 = Conjunto de instruções - FORMATIVO</h3>
            <ul>
            </ul>
        </p>
  
        <p>
          <h3>aula 7 = Conjunto de instruções - FORMATIVO</h3>
            <ul>
            </ul>
        </p>

        <p>
          <h3>aula 8 = Conjunto de instruções - FORMATIVO</h3>
            <ul>
              <li>Paralelismo: dois processadores acessando/modificando sucessivamente um mesmo valor na memória(Data race).</li>
              &nbsp&nbsp&nbsp Operação atômica:
              <ul>
                <li>Linked Load: ll $t0, 0($s1) #$t0 = 0($s1), vincula endereço à operação atômica(ativa flag invisível)</li>
                <li>Store Conditional: sc $t0, 0($s1) #tenta encrever t0 em 0($s1). <br>
                   &nbsp&nbsp&nbsp Se flag ativado, então $t0 = 1 se foi ESCRITO e desativa. <br>
                   &nbsp&nbsp&nbsp Se flag ativado, então $t0 = 0 se NÃO foi ESCRITO.
                <li>Implementando SEMÁFORO:</li>
                <ol>
                  <li>lock: la $t0, sem</li>
                  <li>try:   ll $t1, 0($t0)</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp bne $t1, $zero, try</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp addi $t1, $zero, 1</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp sc $t1, 0($t0)</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp beq $t1, $zero, try</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp jr $ra</li>
                </ol>
                <ol>
                  <li>unlock: la $t0, sem</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsw $t0, 0(t0)</li>
                  <li>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspjr $ra</li>
                </ol>
              </ul>
            </ul>
        </p>

        <p>
          <h3>aula 9 = Avaliação de desempenho - FORMATIVO</h3>
          <ul>Fórmulas: </br>
          <li>T = tempo de execução do programa | P = Ciclos de clock de um programa | Tc = tempo do clock | 
          R = frequência | CPI = média de ciclos por instrução
            <ul>
              <li>T = P.Tc</li>
              <li>T = P/R</li>
              <li>Tc = 1/R <-> R = 1/Tc</li>
              <li>P = I.CPI</li>
              <li>Assim: T = I.CPI.Tc e T = I.CPI/R</li>
              <li>OBS: CPI = média ponderada dos CPI's se mais que 1</li>
            </ul>
            <li>Barreira de potência:
              
            </ul>
        </p>


        <p>
          <h3>aula 10 = Avaliação de desempenho - FORMATIVO</h3>
            <ul>
            </ul>
        </p>

        <p>
          <h3>aula 11 = Ferramentas de programação do sistema - FORMATIVO</h3>
            <ul>
            </ul>
        </p>

        <p>
          <h3>aula 12 = Ferramentas de programação do sistema - FORMATIVO</h3>
            <ul>
            </ul>
        </p>


  </body>
</html>
